---
title: "Comparison of Minimization Randomization with Other Randomization Methods - balance of covariates"
author: "Aleksandra Duda - Tranistion Technologies Science"
date: "`r Sys.Date()`"
output:
  html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Comparison of Minimization Randomization with Other Randomization Methods - balance of covariates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
link-citations: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{=html}
<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>
```

## Introduction

Randomization in clinical trials is the gold standard and is considered the best widely accepted design for evaluating the effectiveness of new treatments compared to alternative treatments (standard of care) or placebo. Randomization has many advantages. Firstly, it allows the elimination of random errors, including selection biases. This helps avoid any bias in the planning stage of the study protocol, influencing the quality of such a study. Additionally, through randomization, it is possible to match groups based on similarity using specified stratifying factors. This enables the even distribution of factors among groups. If the results of the treated group and the control group show differences, it will be the only difference between the study arms. This means that this difference is caused by the treatment, not the variation in groups based on baseline characteristics [@lim2019randomization].

This document provides a summary of the comparison of three randomization methods: simple randomization, block randomization, and adaptive randomization. Simple randomization and adaptive randomization (minimization method) are tools available in the `unbiased` package as `randomize_simple` and `randomize_minimisation_pocock` functions. The comparison aims to demonstrate the superiority of adaptive randomization (minimization method) over other methods in assessing the least imbalance of accompanying variables between therapeutic groups. Monte Carlo simulations were used to generate data, utilizing the `simstudy` package [@goldfeld2020simstudy]. Parameters for the beta distribution of variables were based on data from the publication by @mrozikiewicz2023allogenic and information from researchers.

The document structure is as follows: first, the distributions of selected parameters from the publication are verified; then, data are generated for a specified number of simulations and patients using Monte-Carlo simulations; subsequently, for each randomization method, including minimization with different weights, for each simulation and for each patient, the treatment group is assigned; based on this, data frames are generated for each method; then, using summaries, the results of frequency and chi^2 test or Fisher's exact test for covariates in each method are displayed; finally, three summaries are presented: a boxplot showing the standardized mean difference (SMD) generated as the average from all covariates, violin plots showing the distribution of each covariate for each method, and a summary of success defined as the percentage of events for which the SMD for each covariate is less than 0.2.

```{r setup, warning = FALSE, message=FALSE}
# load packages
library(unbiased)
library(dplyr)
library(devtools)
# installed from github
# devtools::install_github('kaneplusplus/bigmemory')
library(bigmemory)
library(simstudy)
library(tableone)
library(checkmate)
library(ggplot2)
library(gt)
library(gtsummary)
library(truncnorm)
library(tidyverse)
library(randomizeR)
```

## The randomization methods considered for comparison 

In the process of comparing the balance of covariates among randomization methods, three randomization methods have been selected for evaluation:

- **simple randomization** - randomization that gives participants equal chances of being assigned to a particular group, which occurs randomly. The method's advantage lies in its simplicity and the elimination of predictability. However, due to its complete randomness, it may lead to imbalance in sample sizes between groups (even assuming a 1:1 randomization ratio) and imbalances between prognostic factors.

- **block randomization** - a randomization method that takes into account defined covariates and specified allocation ratios for patients in each group. The method involves assigning patients to therapeutic groups in blocks of a fixed size, with the recommendation that the blocks have different sizes. This, to some extent, reduces the risk of researchers predicting future group assignments. In contrast to simple randomization, the block method aims to balance the number of patients in groups, eliminating potential imbalance between groups (@rosenberger2015randomization).

- **adaptive randomization using minimization method** - a randomization method aiming to balance prognostic factors by determining the total imbalance with the emergence of each new patient in the study. The method selects the smallest imbalance from all total imbalances based on a specified method such as variance, and then assigns the patient to the group with the smallest imbalance with a predetermined probability of allocation. This method was described in the publication by @pocock1975sequential.

## Assessment of covariate balance

In the proposed approach to the assessment of randomization methods, the primary objective is to evaluate each method in terms of achieving balance in the specified covariates. The assessment of balance aims to determine whether the distributions of covariates are similarly balanced in each therapeutic group. Based on the literature, standardized mean differences (SMD) have been employed for assessing balance.

The SMD method is one of the most commonly used statistics for assessing the balance of covariates, regardless of the unit of measurement. It is a statistical measure for comparing differences between two groups.The covariates in the examined case are expressed as binary variables. In the case of categorical variables, SMD is calculated using the following formula (@zhang2019balance):

\[ SMD = \frac{{p_1 - p_2}}{{\sqrt{\frac{{p_1 \cdot (1 - p_1) + p_2 \cdot (1 - p_2)}}{2}}}} \],

where:

- \( p_1 \) is the proportion in the first arm,

- \( p_2 \) is the proportion in the second arm.

## Definied number of patients and number of iterations

Firstly, to create the simulation and generate data, it is crucial to determine the number of patients who will be randomized. In the study, it is assumed that 105 patients will be randomized, with 35 patients in each of the research groups (Group A, Group B, Group C) (ratio 1:1:1).

The next step is to define the number of iterations. The more iterations are applied, the greater the certainty about the true outcome. For the Monte Carlo simulation, 1000 iterations have been adopted.

```{r, define-parameters}
# defined number of patients
n <- 105
# defined number of iterations
no_of_iterations <- 10
```

## Defining parameters for Monte-Carlo simulation{#truncparam}

In the process of defining the study for randomization, the following covariates have been selected:

- **gender** [male/female],

- **diabetes type** [type I/type II],

- **HbA1c** [up to 9/9 to 11] [%],

- **tpo2** [up to 50/above 50] [mmHg],

- **age** [up to 55/above 55] [years],

- **wound size** [up to 2/above 2] [cm\(^2\)].

In the case of the variables gender and diabetes type in the publication @mrozikiewicz2023allogenic, they were expressed in the form of frequencies. The remaining variables were presented in terms of measures of central tendency along with an indication of variability, as well as minimum and maximum values. To determine the parameters alpha and beta for the binary distribution, the truncated normal distribution available in the `truncnorm` package was utilized. The truncated normal distribution is often used in statistics and probability modeling when dealing with data that is constrained to a certain range. It is particularly useful when you want to model a random variable that cannot take values beyond certain limits (@burkardt2014truncated).

To generate the necessary information for the remaining covariates, a function `simulate_parameters_trunc` was written, utilizing the `rtruncnorm function`. The parameters `mean`, `sd`, `lower`, `upper` were taken from the publication and based on expertise regarding the ranges for the parameters.

```{r, parameters-function}
# simulation parameters using truncated normal distribution
simulate_parameters_trunc <-
  
  function(n, lower, upper, mean, sd, number) {
    simulate <- sapply(1:1000, function(i)
      rtruncnorm(
        n = n,
        a = lower,
        b = upper,
        mean = mean,
        sd = sd
      )) |>
      as.data.frame()
    
    simulate_long <- simulate |>
      pivot_longer(cols = everything(),
                   names_to = "Simulation",
                   values_to = "Value") |>
      arrange(Simulation)
    
    result <-
      simulate_long |>
      group_by(Simulation) |>
      transmute(Simulation, n = sum(Value <= number)) |>
      distinct()
    
    mean <- mean(result$n)
    
    return(mean)
}
```

```{r, parameters-result}
# Using the function for covariates

# hba1c
hba1c =
  simulate_parameters_trunc(46, 0, 11, 7.41, 1.33, 9)

# tpo2
tpo2 =
  simulate_parameters_trunc(46, 30, 100, 53.4, 18.4, 50)

# age
age =
  simulate_parameters_trunc(46, 0, 100, 59.2, 9.7, 55)

# wound_size
wound_size =
  simulate_parameters_trunc(46, 0, 20, 2.7, 2.28, 2)
```

The results are presented in a table, assuming that the outcome refers to the first category of each parameter.

```{r, parameters-result-table, tab.cap = "Summary of literature verification about strata selected parameters (Mrozikiewicz-Rakowska et. al., 2023)"}
# summary table
data.frame(hba1c, tpo2, age, wound_size) %>%
  rename('wound size' = wound_size) %>%
  pivot_longer(cols = everything(),
               names_to = "parametr",
               values_to = "n") %>%
  mutate(
    n = ceiling(n),
    percent = round(n / 46, 2),
    strata = c('<=9', '<=50', '<=55', '<=2')
  ) %>%
  rename('Percent of N = 46' = percent) %>%
  gt()
```

## Generate data using Monte-Carlo simulations

To generate data based on the assumptions summarized in the last section and taking into account the suggestions from physicians, a function called `build_prior_df` was created. This function, relying on the conjugate beta distribution, generated random samples based on the defined parameters for various variables. Conjugate priors have the advantageous property that, after incorporating data (likelihood), the posterior distribution is of the same type as the prior, simplifying calculations and result interpretation (@hodel2023beta).

```{r, build-prior}
set.seed(123)

# create beta distribution parameters
build_prior_df <- function(no_of_iterations, n) {
  binary_matrix <- tribble(
    ~ var,
    ~ distribution,
    ~ alpha, #1
    ~ beta, #0
    "sex", # Parameters provided by researchers
    "beta",
    1 + 900, #men
    1 + 100, #women
    "diabetes_type", # Parameters provided by researchers
    "beta",
    1 + 150, # type I
    1 + 850, # type II
    "hba1c", # (Mrozikiewicz-Rakowska et. al., 2023)
    "beta",
    1 + 41, # <=9
    1 + 5, # (9,11>
    "tpo2", # (Mrozikiewicz-Rakowska et. al., 2023)
    "beta",
    1 + 17, #<=50 mmHg
    1 + 29, #> 50 mmHg,
    "age", # Parameters provided by researchers
    "beta",
    1+300, # <=55
    1+700, # >55 
    "wound_size", # Parameters provided by researchers
    "beta",
    1+300, # <=2cm^2
    1+700 # > 2cm^2
  ) |>
    rowwise() |>
    mutate(
      mean = alpha / (alpha + beta),
      sd = sqrt(alpha * beta / ((alpha + beta + 1) * (alpha + beta) **
                                  2)),
      example = rbeta(1, shape1 = alpha, shape2 = beta)
    ) |>
    ungroup()
  
  params_binary <-
    mapply(function(n, alpha, beta) {
      rbeta(n, alpha, beta)
    },
    no_of_iterations,
    binary_matrix$alpha,
    binary_matrix$beta,
    SIMPLIFY = FALSE)
  names(params_binary) <- binary_matrix$var
  
  params <-
   params_binary |>
    bind_rows() 
  
  return(params)
}
```

The table contains a summary of the draw results for the distribution of parameters for the first iteration.

```{r, params}
params <-
  build_prior_df(no_of_iterations = no_of_iterations, n = n)

params[1,] |>
  gt() 
```

In the next step, additional variables were defined using the `simstudy` package, utilizing the `defData` function. Due to the likely association between the type of diabetes and age – meaning that the older the patient, the higher the probability of having type II diabetes – a relationship with diabetes was established when defining the `age` variable using a logit function (link = "logit").

```{r, generate-outcomes}
# generate outcomes 
generate_outcomes <- function(row, n) {
  results <-
    row |>
    with({
      simstudy::defData(varname = "sex",
                        formula = sex,
                        dist = "binary") |>
        simstudy::defData(varname = "diabetes_type",
                          formula = diabetes_type,
                          dist = "binary") |>
        simstudy::defData(varname = "hba1c",
                          formula = hba1c,
                          dist = "binary") |>
        simstudy::defData(varname = "tpo2",
                          formula = tpo2,
                          dist = "binary") |>
        simstudy::defData(
          varname = "age",
          # correlation with diabetes type - assumptions - younger patients are more likely to have type I diabetes
          formula = "(diabetes_type==0) * (-3.5)",
          link = "logit",
          dist = "binary"
        ) |>
        simstudy::defData(varname = "wound_size",
                          formula = wound_size,
                          dist = "binary") |>
        simstudy::genData(n, dtDefs = _)
    })
}
```

Using the `generate_outcomes` function, a data frame was generated with an artificially adopted variable `arm`, which will be filled in by subsequent randomization methods in the arm allocation process for all `n` patients in each iteration.

```{r, data-generate}
# generate data
data <-
  params |>
  group_by(simnr = row_number()) |>
  tidyr::nest(.key = "params") |>
  mutate(results = purrr::map(params, generate_outcomes, n)) |>
  select(simnr, results) |>
  tidyr::unnest() |>
  mutate(
    sex = as.character(sex),
    age = as.character(age),
    diabetes_type = as.character(diabetes_type),
    hba1c = as.character(hba1c),
    tpo2 = as.character(tpo2),
    wound_size = as.character(wound_size)
  )

data <-
  data |>
  tibble::add_column(arm = "")
```

The table displays an example distribution of variables for the first 5 rows of the `data` frame for the first iteration.

```{r, data-show}
# first 5 rows of the data
data[1:5, 2:ncol(data)] |>
  gt()
```

## Minimization randomization

To generate appropriate research arms for each simulation, a function called `minimize_results` was written, utilizing the `randomize_minimisation_pocock` function available within the `unbiased` package. The probability parameter was set at the level defined within the function (p = 0.85). In the case of minimization randomization, to verify which type of minimization (with equal weights or unequal weights) was used, three calls to the minimize_results function were prepared:

- **minimize_equal_weights** - each covariate weight takes a value equal to 1 divided by the number of covariates. In this case, the weight is 1/6,

- **minimize_unequal_weights** - following the expert assessment by physicians, parameters with potentially significant impact on treatment outcomes (hba1c, tpo2, wound size) have been assigned a weight of 2. The remaining covariates have been assigned a weight of 1.

- **minimize_unequal_weights_2** - following the expert assessment by physicians, parameters with potentially significant impact on treatment outcomes (hba1c, tpo2, wound size) have been assigned a weight of 3. The remaining covariates have been assigned a weight of 1.


The tables present information about allocations for the first 5 patients in the initial iteration of the simulation.
      
```{r, minimize-results}
# drawing an arm for each patient
minimize_results <-
  function(data, arms, weights) {
    for (i in unique(data$simnr))
    {
      for (j in 1:n)
      {
        current_data <- data[data$simnr == i, ]
        
        current_state <- current_data[1:j, 3:ncol(current_data)]
        
        start <- 1 + (i - 1) * n
        end <- i * n
        
        data[start:end,]$arm[j] <-
          randomize_minimisation_pocock(
            arms = arms,
            current_state = current_state,
            weights = weights
          )
        
        
      }
    }
    return(data)
  }
```

```{r, minimize-equal}
# eqal weights - 1/6
minimize_equal_weights <-
  minimize_results(
    data = data,
    arms = c("armA", "armB", "armC")
  )

minimize_equal_weights[1:5, 2:ncol(minimize_equal_weights)] |>
  gt()
```

```{r, minimize-unequal-1}
# double weights where the covariant is of high clinical significance
minimize_unequal_weights <-
  minimize_results(
    data = data,
    arms = c("armA", "armB", "armC"),
    weights = c(
      "sex" = 1,
      "diabetes_type" = 1,
      "hba1c" = 2,
      "tpo2" = 2,
      "age" = 1,
      "wound_size" = 2
    )
  )

minimize_unequal_weights[1:5, 2:ncol(minimize_unequal_weights)] |>
  gt()
```

```{r, minimize-unequal-2}
# triple weights where the covariant is of high clinical significance
minimize_unequal_weights_2 <-
  minimize_results(
    data = data,
    arms = c("armA", "armB", "armC"),
    weights = c(
      "sex" = 1,
      "diabetes_type" = 1,
      "hba1c" = 3,
      "tpo2" = 3,
      "age" = 1,
      "wound_size" = 3
    )
  )

minimize_unequal_weights_2[1:5, 2:ncol(minimize_unequal_weights_2)] |>
  gt()
```

The `statistic_table` function was developed to provide information on: the distribution of the number of patients across research arms, and the distribution of covariates across research arms, along with p-value information for statistical analyses used to compare proportions - chi^2, and the exact Fisher's test, typically used for small samples.

The function relies on the use of the `tbl_summary` function available in the `gtsummary` package.

```{r, statistics-table}
# generation of frequency and chi^2 statistic values or fisher exact test
statistics_table <-
  function(data) {
    data |>
      filter(simnr == 1) |>
      mutate(
        sex = ifelse(sex == '1', "men", "women"),
        diabetes_type = ifelse(diabetes_type == "1", "type1", "type2"),
        hba1c = ifelse(hba1c == '1', "<=9", "(9,11>"),
        tpo2 = ifelse(tpo2 == '1', "<=50", ">50"),
        age = ifelse(age == '1', "<=55", ">50"),
        wound_size = ifelse(wound_size == '1', "<=2", ">2")
      ) |>
      tbl_summary(
        include = c(sex, diabetes_type, hba1c, tpo2, age, wound_size),
        by = arm
      ) |>
      modify_header(label = "") |>
      modify_header(all_stat_cols() ~  "**{level}**, N = {n}")  |>
      bold_labels() |>
      add_p()
  }
```

The table presents a statistical summary of results for the first iteration for:

- **Minimization with all weights equal to 1/6**.

```{r, chi2-1, tab.cap = "Summary of proportion test for minimization randomization with equal weights"}
statistics_table(minimize_equal_weights) 
```

- **Minimization with weights 2:1**.

```{r, chi2-2, tab.cap = "Summary of proportion test for minimization randomization with equal weights"}
statistics_table(minimize_unequal_weights) 
```

- **Minimization with weights 3:1**.

```{r, chi2-3, tab.cap = "Summary of proportion test for minimization randomization with equal weights"}
statistics_table(minimize_unequal_weights_2) 
```

## Simple randomization

In the next step, appropriate arms were generated for patients using simple randomization, available through the `unbiased` package - the `randomize_simple` function. The `simple_results` function was called within `simple_data`, considering the initial assumption of assigning patients to three arms in a 1:1:1 ratio.

Since this is simple randomization, it does not take into account the initial covariates, and treatment assignment occurs randomly.

```{r, simple-result}
# simple randomization
simple_results <-
  function(data, arms, ratio) {
    for (i in unique(data$simnr))
    {
      for (j in 1:n)
      {
        current_data <- data[data$simnr == i, ]
        
        start <- 1 + (i - 1) * n
        end <- i * n
        
        data[start:end,]$arm[j] <-
           randomize_simple(arms, ratio)
        
        
      }
    }
    return(data)
  }
```

The table illustrates an example of data output for simple randomization in the first iteration.

```{r, simple-data}
simple_data <-
  simple_results(data, c("armA", "armB", "armC"), c("armB" = 1L,"armA" = 1L, "armC" = 1L))

simple_data[1:5, 2:ncol(simple_data)] |>
  gt()
```
The table presents a statistical summary of results for the first iteration.

```{r, chi2-4, tab.cap = "Summary of proportion test for simple randomization"}
statistics_table(simple_data)
```

## Block randomization

Block randomization, as opposed to minimization and simple randomization methods, was developed based on the `rbprPar` function available in the `randomizeR` package. Using this, the `block_rand` function was created, which, based on the defined number of patients, arms, and a list of stratifying factors, generates a randomization list with a length equal to the number of patients multiplied by the product of categories in each covariate. In the case of the specified data in the document, for one iteration, it amounts to **105 * 2^6 = 6720 rows**.

```{r, block-rand}
# Function to generate a randomisation list
block_rand <-
  function(N, block, n_groups, strata) {
    strata_grid = expand.grid(strata)
    
    strata_n = nrow(strata_grid)
    
    ratio = rep(1, n_groups)
    
    arm_names = LETTERS[1:n_groups]
    
    genSeq_list <- lapply(seq_len(strata_n), function(i) {
      rand <- rpbrPar(
        N = N,
        rb = block,
        K = n_groups,
        ratio = ratio,
        groups = arm_names,
        filledBlock = FALSE
      )
      getRandList(genSeq(rand))[1,]
    })
    df_list = tibble::tibble()
    for (i in seq_len(strata_n)) {
      local_df <- strata_grid %>%
        dplyr::slice(i) %>%
        dplyr::mutate(count = N) %>%
        tidyr::uncount(count) %>%
        tibble::add_column(rand_arm = genSeq_list[[i]])
      df_list <- rbind(local_df, df_list)
    }
    return(df_list)
  }
```

Lists of randomization codes were generated for each iteration based on the function, assuming a block vector of c(3,6,9). This ensures blinding and facilitates ease in predicting which group the next patient would be assigned to.

```{r, rand-data}
# generate randomization lists for each iterations
rand_data <- tibble::tibble()

for (i in unique(data$simnr)) {
  simulation_result <-   
    block_rand(
    N = n,
    block = c(3, 6, 9),
    n_groups = 3,
    strata =
      list(
        sex = c("0", "1"),
        diabetes_type = c("0", "1"),
        hba1c = c("0", "1"),
        tpo2 = c("0", "1"),
        age = c("0", "1"),
        wound_size = c("0", "1")
      )
  ) |> dplyr::mutate(simnr = i) |>
    select(simnr, everything())
  
  rand_data <- dplyr::bind_rows(rand_data, simulation_result)
}
```

In the next step, patients were assigned to research groups using the `block_results` function. For each iteration, the first available code from the randomization list that meets specific conditions is selected, and then it is removed from the list of available codes. Based on this, research arms are generated to ensure the appropriate number of patients in each group (based on the assumed ratio of 1:1:1).

```{r, block-results}
# Generate a research arm for patients in each iteration
block_results <- function(data, datarand) {
  
  for (k in unique(data$simnr)) {
    
    datax <- data[data$simnr == k, ]
      
    datay <- datarand[datarand$simnr == k, ]
      
    for (i in datax$id) {
      
       matching_rows <-
        which(
          datay[2] == datax[3][datax[2] == i] &
            datay[3] == datax[4][datax[2] == i] &
            datay[4] == datax[5][datax[2] == i] &
            datay[5] == datax[6][datax[2] == i] &
            datay[6] == datax[7][datax[2] == i] &
            datay[7] == datax[8][datax[2] == i]
        )
      
      if (length(matching_rows) > 0) {
        id <- i
        arm <- datay$rand_arm[matching_rows[1]]
        
        start <- 1 + (k - 1) * n
        end <- k * n
        
        data[start:end,]$arm[i] <- arm
        
        # Delate row with randomization list
        datay <- datay[-matching_rows[1], , drop = FALSE]
      }
    }
  }
  
  return(data)
}
```

The table shows the assignment of patients to groups using block randomisation for the first 5 rows, first iteration.

```{r, block-data-show}
block_data <-
  block_results(data, rand_data)

block_data[1:5, 2:ncol(block_data)] |>
  gt()
```

The table presents a statistical summary of results for the first iteration.

```{r, chi2-5,  tab.cap = "Summary of proportion test for simple randomization"}
statistics_table(block_data)
```

## Check balance using smd test

In order to select the test and define the precision at a specified level, above which we assume no imbalance, a literature analysis was conducted based on publications such as @lee2021estimating, @austin2009balance, @doah2021impact, @brown2020novel, @nguyen2017double, @sanchez2003effect, @lee2022propensity.

To assess the balance for covariates between the research groups A, B, C, the Standardized Mean Difference (SMD) test was employed, which compares two groups. Since there are three groups in the example, the SMD test is computed for each pair of comparisons: A vs B, A vs C, and B vs C. The average SMD test for a given covariate is then calculated based on these comparisons.

In the literature analysis, the precision level ranged between 0.1-0.2. For small samples, it was expected that the SMD test would exceed 0.2 (@austin2009balance). Additionally, according to the publication by @sanchez2003effect, there is no golden standard that dictates a specific threshold for the SMD test to be considered balanced. Generally, the smaller the SMD test, the smaller the difference in covariate imbalance.

In the analyzed example, due to the sample size of 105 patients, a threshold of 0.2 for the SMD test was adopted.

```{r, define-strata-vars}
# definied covariants, and strata
vars = c("sex", "age", "diabetes_type", "wound_size", "tpo2", "hba1c")
strata = "arm"
```

A function called `smd_covariants_data` was written to generate frames that produce the SMD test for each covariate in each iteration, utilizing the `CreateTableOne` function available in the `tableone` package. In cases where the test result is <0.001, a value of 0 was assigned.

The results for each randomization method were stored in the `cov_balance_data`.

```{r, smd-covariants-data}
smd_covariants_data <-
  function(data, vars, strata) {
    x <-
      rep(unique(data$simnr), times = rep(1, times = length(unique(data$simnr))) * length(vars))
    
    result_table <-
      data.frame(simnr = x, covariants = rep(vars, length(unique(data$simnr)))) |>
      tibble::add_column(results = "")
    
    for (i in 1:length(unique(data$simnr))) {
      current_data <- data[data$simnr == i,]
      
      # check SMD for any covariants
      tab <-
        CreateTableOne(vars = vars,
                       data = current_data,
                       strata = strata)
      results_smd <- print(tab, smd = TRUE, TEST = FALSE) |>
        as.data.frame()
      results_smd <-
        results_smd[2:nrow(results_smd),] |>
        mutate(SMD = case_when(SMD == "<0.001" ~ "0",
                               TRUE ~ SMD),
               SMD = as.numeric(SMD)) 
      results <- as.numeric(results_smd$SMD)
      
      start <- 1 + (i - 1) * length(vars)
      end <- i * length(vars)
      
      result_table[start:end, ]$results <- results
    }
    result_table <-
      result_table |>
      mutate(results = as.numeric(results))
    return(result_table)
  }
```

```{r, cov-balance-data, echo = TRUE, results='hide'}
cov1 <-
  smd_covariants_data(data = minimize_equal_weights,
                vars = vars,
                strata = strata) |>
  tibble::add_column(method = "minimize equal")
cov2 <-
  smd_covariants_data(data = minimize_unequal_weights,
                vars = vars,
                strata = strata) |>
  tibble::add_column(method = "minimize unequal 2:1")
cov3 <-
  smd_covariants_data(data = simple_data,
                vars = vars,
                strata = strata) |>
  tibble::add_column(method = "simple randomization")

cov4 <-
  smd_covariants_data(
    data = block_data,
    vars = vars,
    strata = strata
  ) |>
  tibble::add_column(method = "block randomization")

cov5 <-
  smd_covariants_data(
    data = minimize_unequal_weights_2,
    vars = vars,
    strata = strata
  ) |>
  tibble::add_column(method = "minimize unequal 3:1")


cov_balance_data <-
  bind_rows(cov1, cov2, cov3, cov4, cov5)
```

Below are the results of the SMD test presented in the form of boxplot and violin plot, depicting the outcomes for each randomization method. The red dashed line indicates the adopted precision threshold.

- **Boxplot of the combined results**

```{r, boxplot, fig.cap= "Summary average smd in each randomization methods", warning=FALSE, fig.width=9, fig.height=6}
# boxplot
cov_balance_data |>
  select(simnr, results, method) |>
  group_by(simnr, method) |>
  mutate(results = mean(results)) |>
  distinct()  |>
  ggplot(aes(x = method, y = results, fill = method)) +
  geom_boxplot() +
  geom_hline(yintercept = 0.2, linetype = "dashed", color = "red") +
  theme_bw()
```

- **Violin plot**

```{r, violinplot, fig.cap= "Summary smd in each randomization methods in each covariants", warning = FALSE, fig.width=9, fig.height=6}
# violin plot 
cov_balance_data |>
  ggplot(aes(x = method, y = results, fill = covariants)) +
  geom_violin() +
  geom_hline(yintercept = 0.2,
             linetype = "dashed",
             color = "red") +
  theme_bw()
```

- **Summary table of success**

Based on the specified precision threshold of 0.2, a function defining randomization success, named `success_power`, was developed. If the SMD test value for each covariate in a given iteration is above 0.2, the function defines the analysis data as 'failure' - 0; otherwise, it is defined as 'success' - 1.

The final success power is calculated as the sum of successes in each iteration divided by the total number of specified iterations.

The results defined in variables min1-min5 are summarized in a table as the percentage of success for each randomization method.

```{r, success-power}
# function defining success of randomisation
success_power <-
  function(cov_data) {
    result_table <-
      data.frame(simnr = unique(cov_data$simnr),
                 results = numeric(length(unique(cov_data$simnr))))
    for (i in 1:length(unique(data$simnr))) {
      current_data <- cov_data[cov_data$simnr == i,]
      
      results <- ifelse(any(current_data$results > 0.2), 0, 1)
      result_table$results[i] <- results
      
      success <-
        sum(result_table$results) / nrow(result_table) * 100
      
    }
    
    return(success)
    
  }
```

```{r, success-min, echo = TRUE, results='hide'}
min_1 <-
  success_power(cov1)
min_2 <-
  success_power(cov2)
min_3 <-
  success_power(cov3)

min_4 <-
  success_power(cov4)

min_5 <-
  success_power(cov5)
```

```{r, success-result-data, tab.cap = "Summary of percent success in each randomization methods"}
data.frame(
  method = c(
    'minimize equal weights',
    'minimize unequal weights 2:1',
    'simple randomization',
    'block randomization',
    'minimize unequal weights 3:1'
  ),
  results_power = c(min_1, min_2, min_3, min_4, min_5)
) |>
  as.data.frame() |>
  rename(`power results [%]` = results_power) |>
  gt()
```

## Conclusion

Considering all three randomization methods: minimization, block randomization, and simple randomization, minimization performs the best in terms of covariate balance. Simple randomization has a significant drawback, as patient allocation to arms occurs randomly with equal probability. This leads to an imbalance in both the number of patients and covariate balance, which is also random.

On the other hand, block randomization performs very well in balancing the number of patients in groups in a specified allocation ratio. However, its effect size power is lower for covariate balance compared to minimization.

Minimization, on the other hand, provides the highest success power by ensuring balance across covariates between groups.

# References

---
nocite: '@*'
...


